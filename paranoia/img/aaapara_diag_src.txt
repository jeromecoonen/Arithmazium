// para_art_ouflow.txt -- source for over/underflow diagrams

FILE 4_3_round
TIC
b "1.0" "2.0" (b, 1, 141, "4/3") (h, 1, 256, "3/2")
FEND

FILE semilit_samp_a
CNC10
ONE = 1.0
b jjj100j...j00
The constant value one
CNC10
ONE_PLUS_ULP = ...
b jjj100j...j01
The next number larger than one
CNC10
ULP_OF_ONE_PLUS = ...
b jjj000j...j01 e3
A unit in the last place of one;|ote the value 1 is subtracted off
FEND

FILE semilit_samp_b
CNC10
ONE_MINUS_ULP = ...
b jjj011j...j111 e13
Next number smaller than one, in binary;|note the new digit position
CNC10
# ...in decimal
d jjj099j...j999
Bold digits
CNC10
# ...in octal
o jjj077j...j777
Italic digits
CNC10
# ...in hexadecimal
h jjj0ffj...jfff
Bold italic digits
FEND


FILE big_2_nth_bin
CNC10
y = x + ONE
b jjj010j...j001 p14
Largest exact sum 2**n + 1
CNC10
y = x + ONE   # must round
b jjj10jj...j0?1 p14 e13
Will the trailing 1 round off or up to 2?
CNC10
  = x + TWO   # rounded up
b jjj10jj...j010 p14
In the unlikely event of rounding up|he trailing 1 is in the 2's place
FEND

FILE big_2_nth_oct
CNC10
y = x + ONE
o jjj040j...j001 p14
Largest exact sum 2**n + 1, octal
CNC10
y = x + ONE
h jjj080j...j001 p14
Largest exact sum 2**n + 1, hexadecimal
FEND

FILE big_2_nth_dec
CNC5
y = x + ONE
d jjj032769 p9
2**15 + 1, exact in 5 digits
CNC5
y = x + ONE
d jjj065537 p9
2**16 + 1, exact
CNC5
y = x + ONE
d jjj131073 p9 e8
2**16 + 1, with the 3 to be rounded off
FEND

FILE big_2_nth_hexfrac
CNC6
y = x + ONE
h jjj04000010 p10 e10
2**22 + 1, hex
CNC6
y = x + ONE
h jjj08000010 p10 e10
2**23 + 1
CNC6
y = x + ONE
h jjj1000001 p10 e9
2**24 + 1, the 1 must round off,|whether the precision is 6 or 6.5 hex digits
FEND

FILE find_radix_bin
CNC10
b = big + y   # y = 1
b jjj100j...j001 p14
VAX add-half-and-chop will round this up
CNC10
b = big + y   # y = 2
b jjj100j...j010 p14
Add's into the 2's place, giving the radix
FEND

FILE find_radix_dec
CNC10
b = big + y   # y = 4
d jjjxxj...jxz4 p14
Most arithmetics would round the 4 down
CNC10
b = big + y   # y = 8
d jjj1xxj...jxz8 p14 e13
Modern decimal arithmetic would round|into the z digit
CNC10
b = big + y   # y = 16
d jjj1xxj...jxZ6 p14 e13
In chopped arithmetic this bumps z to Z = z + 1|possibly with a carry into the next digit
FEND


FILE precision_a
CNC10
# in loop: big_b + 1.0
b jjj010j...j01 p13
large power of B to which 1 can be added
CNC10
# next big_b + 1.0
b jjj100j...j01 p13
largest power of B to which 1 can be added
CNC10
# final big_b + 1.0
b jj1000j...j?0 p13 e11
the added 1 rounds off on most machines,|binary VAX with add-half-and-chop will round up
FEND

FILE precision_b
CNC10
BIG_B_NTH = ...
b jj1000j...j00 p13
power of B such that added 1 rounds off
CNC10
ONE / BIG_B_NTH
b jjj000j...j001 p4
1/B of a unit in the last place of 1
CNC10
(ONE / BIG_B_NTH) * B
b jjj000j...j01 p4
a unit in the last place of 1
FEND

FILE precision_c
CNC10
return ...
b jj1000j...j00 p13 e11
highlighted low-order digit is the B's place
FEND

FILE precision_d
CNC10
y = big_b + ONE
b jjj100j...j01 p13
the largest power of B to which 1 can be added exactly
CNC10
# next y = big_b * B + ONE
b jj1000j...j01 p13 e12
the 1 must either round off or round into the B's place
FEND

FILE precision_e
CNC6
y = big_b + ONE
h jjjjj100100 p9
the last hex digit is 1, 2, or 3 bits wide
CNC6
# next y
h jjjj100010 p9
adding 1 is still exact
CNC6
# next y
h jjj100001 p9 e8
the circled hex digit has no one 1's bit
FEND



FILE 4_3_round_d
TIC
d "1.0" "10.0" (b, 1, 256, "4/3")
FEND

FILE ulp_one_plus
CNC10
FOUR / THREE
b jjj1010...0101010 e12
the highlighted bit is rounded|whether the precision is even or odd
CNC10
x = FOUR / THREE   # rounded
b jjj1010...011 e12
rounded up by 1/3 ulp of 1.0
CNC10
third = x - ONE
b jjj0010...011
subtraction is exact, preserving the rounding error
CNC10
sixth = ONE_HALF - third
b jjj0001...101
1/6 is rounded down by 1/3 ulp of 1.0
FEND

FILE ulp_one_plus_b
CNC10
ONE
b jjj100j...j00
1.0, showing binary point alignment
CNC10
u = ...
b jjj000j...j11
suppose u is 3 ulps of 1.0
CNC10
x = ONE_HALF * u + ...
b jjj000j...j0110???
x is half u, with nonzero low bits
FEND

FILE ulp_one_plus_c
CNC6
x = FOUR / THREE
d jjj133333333 e9
the low-order 3s will round off
CNC6
third = x - ONE
d jjj033333
1/3 is rounded down in the low digit of 1.0
CNC6
sixth = ONE_HALF - third
d jjj016667
1/6 is rounded up
FEND


FILE ulp_one_minus
CNC10
x = TWO / THREE
b jjj0101...10101010 e13
the highlighted bit is rounded|whether the precision is even or odd
CNC10
sixth = x - ONE_HALF
b jjj0001...101? e13
the subtraction is exact, preserving the rounding error
CNC10
third = sixth + sixth
b jjj0010...01?0 e12
doubling shifts the rounding error
CNC10
x = third - ONE_HALF
b jjj0001...1??0
negative 1/6 is rounded in the opposite direction of sixth
FEND

FILE ulp_one_minus_b
CNC10
ONE
b jjj100j...j00
1.0, showing binary point alignment
CNC10
u = ...
b jjj000j...j11
suppose u is 3 ulps of 1.0
CNC10
x = ONE_HALF * u + ...
b jjj000j...j0110 ... xx
x is half u, with nonzero low bits
FEND

FILE ulp_one_minus_c
CNC6
x = 4.0 / 3.0
d jjj133333333 e9
the low-order 3s will round off
CNC6
third = x - ONE
d jjj033333
1/3 is rounded down in the low digit of 1.0
CNC6
sixth = ONE_HALF - third
d jjj016667
1/6 is rounded up
FEND





FILE uflo_tiny_B_a
CNC10
less_tiny = tiny
b jj1000j...j00
Twice the smallest normal number
CNC10
tiny = z
b jjj100j...j00
The smallest normal number
CNC10
z = z * H
b jjj010j...j00 e4
IEEE: denormalize to half the|smallest normal number, exactly
CNC10
z = z * H
b jjj000j...j00 e4
Plan B: flush underflow to zero
FEND

FILE uflo_tiny_x_b
CNC10
tiny = tinier
b jjj100j...j01
smallest normal number plus an ulp
CNC10
tinier = too_tiny
b jjj010j...j001 e13
Low-order bit typically rounds off,|but could round up
CNC10
save_tiny_2 = ...
b jjj010j...j00 e12
Scale too_tiny back by 1/H|highlighted bit might be 1
CNC10
tiny_delta = ...
b jjj000j...j01 e12
Smallest positive value
FEND
