"""START PARANOIA EXECUTION"""
# Small floating point constants.
# First two assignments use coerced integer right - hand sides.
ZERO = float(0)
ONE = float(1)
TWO = ONE + ONE
THREE = TWO + ONE
FOUR = THREE + ONE
FIVE = FOUR + ONE
EIGHT = FOUR + FOUR
NINE = THREE * THREE
TWENTY_SEVEN = NINE * THREE
THIRTY_TWO = FOUR * EIGHT
TWOFORTY = FOUR * FIVE * THREE * FOUR
MINUS_ONE = -ONE
ONE_HALF = ONE / TWO
ONE_AND_HALF = ONE + ONE_HALF
error_count[err_failure] = 0
error_count[err_serious] = 0
error_count[err_defect] = 0
error_count[err_flaw] = 0
PageNo = 1
milestone = 0   #==============================
Instructions()
Pause()
Heading()
Pause()
Characteristics()
Pause()
History()
Pause()
milestone = 7   #==============================
print("Program is now RUNNING tests on small integers:")

TstCond(err_failure, (ZERO + ZERO == ZERO)
        and (ONE - ONE == ZERO)
        and (ONE > ZERO)
        and (ONE + ONE == TWO),
        "0+0 != 0, 1-1 != 0, 1 <= 0, or 1+1 != 2")
z = -ZERO
if (z != 0.0):
    error_count[err_failure] += 1
    print("Comparison alleges that -0.0 is Non-zero!")
    ULP_OF_ONE_PLUS = 0.001   # todo: elaborate on this fallback test
    B = 1
    discard = does_tiny_value_misbehave(z)
TstCond(err_failure, (THREE == TWO + ONE)
        and (FOUR == THREE + ONE)
        and (FOUR + TWO * (-TWO) == ZERO)
        and (FOUR - THREE - ONE == ZERO),
        "3 != 2+1, 4 != 3+1, 4+2*(-2) != 0, or 4-3-1 != 0")
TstCond(err_failure, (MINUS_ONE == (0 - ONE))
        and (MINUS_ONE + ONE == ZERO)
        and (ONE + MINUS_ONE == ZERO)
        and (MINUS_ONE + FABS(ONE) == ZERO)
        and (MINUS_ONE + MINUS_ONE * MINUS_ONE == ZERO),
        "-1+1 != 0, (-1)+abs(1) != 0, or -1+(-1)*(-1) != 0")
TstCond(err_failure, ONE_HALF + MINUS_ONE + ONE_HALF == ZERO,
        "1/2 + (-1) + 1/2 != 0")
milestone = 10   #==============================
TstCond(err_failure, (NINE == THREE * THREE)
         and (TWENTY_SEVEN == NINE * THREE) and (EIGHT == FOUR + FOUR)
         and (THIRTY_TWO == EIGHT * FOUR)
         and (THIRTY_TWO - TWENTY_SEVEN - FOUR - ONE == ZERO),
         "9 != 3*3, 27 != 9*3, 32 != 8*4, or 32-27-4-1 != 0")
TstCond(err_failure, (FIVE == FOUR + ONE)
         and (TWOFORTY == FOUR * FIVE * THREE * FOUR)
         and (TWOFORTY / THREE - FOUR * FOUR * FIVE == ZERO)
         and ( TWOFORTY / FOUR - FIVE * THREE * FOUR == ZERO)
         and ( TWOFORTY / FIVE - FOUR * THREE * FOUR == ZERO),
         "5 != 4+1, 240/3 != 80, 240/4 != 60, or 240/5 != 48")
if (error_count[err_failure] == 0):
    print("-1, 0, 1/2, 1, 2, 3, 4, 5, 9, 27, 32 & 240 are O.K.")

print("Searching for B and PRECISION.")
big_2_nth = find_big_two_to_the_nth()
B = find_radix_from_2_nth(big_2_nth)
# JTC: Can't find a case of B < 2.  For log arithmetic base 2, e, and 10,
# B comes out 2 or greater.
# TODO: continue investigating.
if B < TWO:
    B = ONE
print("B = {:0.4f} .\n".format(B))
# Compute PRECSION and BIG_B_NTH == B^PRECISION barely satisfying
# (BIG_B_NTH+1)-BIG_B_NTH == 1...
PRECISION = ZERO
if B == ONE:
    BIG_B_NTH = big_2_nth
else:
    PRECISION, BIG_B_NTH = find_precision_big_B_nth(B)

guess_ulp_of_one_minus = ONE / BIG_B_NTH
guess_ulp_of_one_plus = B * guess_ulp_of_one_minus
print("Closest relative separation found is ULP_OF_ONE_MINUS = {:0.7e} .".format(guess_ulp_of_one_minus))
print("Recalculating radix and precision")
ULP_OF_ONE_PLUS = find_ulp_of_one_plus(guess_ulp_of_one_plus)
ULP_OF_ONE_MINUS = find_ulp_of_one_minus(guess_ulp_of_one_minus)
if (ULP_OF_ONE_MINUS == guess_ulp_of_one_minus):
    print("confirms closest relative separation ULP_OF_ONE_MINUS ")
else:
    print("gets better closest relative separation ULP_OF_ONE_MINUS = {:0.7e} .".format(ULP_OF_ONE_MINUS))
BIG_B_NTH = ONE / ULP_OF_ONE_MINUS
ONE_MINUS_ULP = (ONE_HALF - ULP_OF_ONE_MINUS) + ONE_HALF
save_b = B
B = FLOOR(0.01 + ULP_OF_ONE_PLUS / ULP_OF_ONE_MINUS)
B_OVER_TWO = B / TWO
ONE_OVER_B = ONE / B
if (B == save_b):
    print("B confirmed.")
else:
    print("MYSTERY: recalculated B = {:0.7e} .".format(B))
TstCond(err_defect, B <= EIGHT + EIGHT,
       "B is too big: roundoff problems")
TstCond(err_flaw, (B == TWO) or (B == 10)
       or (B == ONE), "B is not as good as 2 or 10")
milestone = 20   #==============================
TstCond(err_failure, ONE_MINUS_ULP - ONE_HALF < ONE_HALF,
       "(1-ULP_OF_ONE_MINUS)-1/2 < 1/2 is FALSE, prog. fails?")

# BUG in C version. The point is to try two cases of x.
for x in [ONE_MINUS_ULP, ONE + ULP_OF_ONE_PLUS]:
    y = x - ONE_HALF
    z = y - ONE_HALF
    TstCond(err_failure, (x != ONE)
           or (z == ZERO), "Comparison is fuzzy,x=1 but x-1/2-1/2 != 0")

milestone = 25   #==============================
# ... B_MINUS_ULP = nextafter(B, 0)
B_MINUS_ULP = B - ONE
B_MINUS_ULP = (B_MINUS_ULP - ULP_OF_ONE_PLUS) + ONE
# A = 2 if B = 2**k or arithmetic is logarithmic; it's 10 if B=10
# C = 1/B**K not too close to underflow, useful for over/underflow analysis.
# H = min(1/B, 1/2).
A, ONE_OVER_A = compute_A_and_inverse(B)
C, ONE_OVER_C = compute_C_and_inverse()
H, ONE_OVER_H = compute_H_and_inverse()
SAFE_ULPS_OF_ONE = compute_SAFE_ULPS_OF_ONE()   # 1 or B ulps of one
# Purify Integers was the original comment. The following test assumes
# B=1 for log arithmetic, before any fractional part of the precision
# is "purified".
if (B != ONE):
    PRECISION = standardize_fractional_precision(ULP_OF_ONE_MINUS, B)

if (PRECISION != FLOOR(PRECISION)) or (B == ONE):
    print("PRECISION cannot be characterized by an Integer number")
    print("of significant digits but, by itself, this is a minor flaw.")

if B == ONE:
    print("logarithmic encoding has precision characterized solely "
          +"by ULP_OF_ONE_MINUS.")
else:
    print("The number of significant digits of the B is {:0.4f} .".
          format(PRECISION))
TstCond(err_serious, ULP_OF_ONE_PLUS * NINE * NINE * TWOFORTY < ONE,
       "PRECISION worse than 5 decimal figures  ")
milestone = 30   #==============================
test_for_extra_precise_subepressions()
Pause()
milestone = 35   #==============================
test_normalized_subtraction()
flags["mult_guard_digit"] = does_mult_have_guard_digit()
test_mult_low_digits()
flags["div_guard_digit"] = does_div_have_guard_digit()
flags["add_sub_guard_digit"] = does_add_sub_have_guard_digit()

if (ONE_MINUS_ULP != ONE and ONE_MINUS_ULP - ONE >= ZERO):
    BadCond(err_serious, "comparison alleges  (1-ULP_OF_ONE_MINUS) < 1  although")
    print("  subtraction yields  (1-ULP_OF_ONE_MINUS) - 1 = 0 , thereby vitiating")
    print("  such precautions against division by zero as")
    print("  ...  if (x == 1.0) {.....} else {.../(x-1.0)...}")

if flags["mult_guard_digit"]:
    print("    * appears to have a guard digit, as it should.")
if flags["div_guard_digit"]:
    print("    / appears to have a guard digit, as it should.")
if flags["add_sub_guard_digit"]:
    print("    - appears to have a guard digit, as it should.")
milestone = 40   #==============================
Pause()
print("Checking rounding on multiply, divide and add/subtract. ")
flags["mult_rounding"] = how_does_mult_round()

milestone = 45   #==============================
flags["div_rounding"] = how_does_div_round()
TstCond(err_failure, ONE_OVER_B * B - ONE_HALF == ONE_HALF,
       "B * ( 1 / B ) differs from 1")
milestone = 50   #==============================
TstCond(err_failure, (ONE_MINUS_ULP + ULP_OF_ONE_MINUS) - ONE_HALF == ONE_HALF
       and (B_MINUS_ULP + ULP_OF_ONE_PLUS ) - ONE == B - ONE,
       "Incomplete carry-propagation in Addition")

flags["add_sub_rounding"] = how_does_add_sub_round()

# The boolean set_sticky is used to indicate the presence of a sticky bit
# below. It is cleared if the first simple test fails.
set_sticky = rounding_symmetry_test()

if (flags["mult_guard_digit"] and flags["div_guard_digit"]
        and flags["add_sub_guard_digit"]
        and flags["mult_rounding"] == "rounded"
        and flags["div_rounding"] == "rounded"
        and flags["add_sub_rounding"] == "rounded"
        and FLOOR(B_OVER_TWO) == B_OVER_TWO):
    print("Checking for sticky bit.")
    set_sticky &= has_sticky_bit()

flags["uses_sticky_bit"] = set_sticky

if flags["uses_sticky_bit"]:
    print("Sticky bit apparently used correctly.")
else:
    print("Sticky bit used incorrectly or not at all.")
TstCond(err_flaw, (flags["mult_guard_digit"]
               and flags["div_guard_digit"]
               and flags["add_sub_guard_digit"]
               and flags["mult_rounding"] != "other"
               and flags["div_rounding"] != "other"
               and flags["add_sub_rounding"] != "other"),
        "lack(s) of guard digits or failure(s) to correctly round or chop\n"
        + "(noted above) count as one flaw in the final tally below")
milestone = 60   #==============================
print("")
print("Does Multiplication commute?  ", end="")
print("Testing on {:d} random pairs.".format(NUM_TRIALS))
test_mult_commutivity(NUM_TRIALS)
milestone = 70   #==============================
print("\nRunning test of square root(x).")
TstCond(err_failure, (ZERO == SQRT(ZERO))
       and (- ZERO == SQRT(- ZERO))
       and (ONE == SQRT(ONE)), "Square root of 0.0, -0.0 or 1.0 wrong")
min_sqrt_error = ZERO
max_sqrt_error = ZERO
ok = True
ok &= is_x_sqrt_xx(B, ULP_OF_ONE_PLUS, err_serious)
ok &= is_x_sqrt_xx(ONE_OVER_B, ONE_OVER_B * ULP_OF_ONE_MINUS, err_serious)
# ***BUG -- case of W = B^P, missing from C, but in BASIC 3170
ok &= is_x_sqrt_xx(BIG_B_NTH, ONE, err_serious)
ok &= is_x_sqrt_xx(ULP_OF_ONE_MINUS, ULP_OF_ONE_MINUS * ULP_OF_ONE_MINUS,
                   err_serious)
if not ok:
    Pause()

print("Testing if sqrt(x * x) == x for {:d} Integers x.".format(NUM_TRIALS))
x = TWO   # Default start point for log arithmetic
y = B
if B != ONE:    # ***TODO: log arithmetic issue
    while True:
        x = y
        y = B * y
        if y - x >= NUM_TRIALS: break
ulp = x * ULP_OF_ONE_MINUS    # ***Changed from ..._PLUS
for _ in range(NUM_TRIALS):
    x = x + ONE    # Why increment first????  Could hit next B-ade
    if not is_x_sqrt_xx(x, ulp, err_defect): break

print("Test for sqrt monotonicity.")
test_sqrt_monotonicity()
milestone = 80   #==============================
print("post mono test")
print("min_sqrt_error = {:0.17e}".format(min_sqrt_error))
print("max_sqrt_error = {:0.17e}".format(max_sqrt_error))
min_sqrt_error = min_sqrt_error + ONE_HALF
max_sqrt_error = max_sqrt_error - ONE_HALF
y = (SQRT(ONE + ULP_OF_ONE_PLUS) - ONE) / ULP_OF_ONE_PLUS
err = (y - ONE) + ULP_OF_ONE_PLUS / EIGHT
if err > max_sqrt_error:
    max_sqrt_error = err
err = y + ULP_OF_ONE_PLUS / EIGHT
if err < min_sqrt_error:
    min_sqrt_error = err
print("post 1 + ulp test")
print("min_sqrt_error = {:0.17e}".format(min_sqrt_error))
print("max_sqrt_error = {:0.17e}".format(max_sqrt_error))
y = ((SQRT(ONE_MINUS_ULP) - ULP_OF_ONE_PLUS) - (ONE - ULP_OF_ONE_PLUS)) / ULP_OF_ONE_MINUS
print("sqrt(1-ulp) = {:0.17e}".format(SQRT(ONE_MINUS_ULP)))
print("y = {:0.17e}".format(y))
err = y + ULP_OF_ONE_MINUS / EIGHT
if err > max_sqrt_error:
    max_sqrt_error = err
err = (y + ONE) + ULP_OF_ONE_MINUS / EIGHT
if err < min_sqrt_error:
    min_sqrt_error = err
print("post 1 - ulp test")
print("min_sqrt_error = {:0.17e}".format(min_sqrt_error))
print("max_sqrt_error = {:0.17e}".format(max_sqrt_error))
ulp = ULP_OF_ONE_PLUS
x = ulp
for Indx in range(1, 4):
    y = SQRT((x + ULP_OF_ONE_MINUS + x) + ONE_MINUS_ULP)
    y = ((y - ULP_OF_ONE_PLUS) - ((ONE - ULP_OF_ONE_PLUS) + x)) / ulp
    z = ((ULP_OF_ONE_MINUS - x) + ONE_MINUS_ULP) * ONE_HALF * x * x / ulp
    err = (y + ONE_HALF) + z
    if err < min_sqrt_error:
        min_sqrt_error = err
    err = (y - ONE_HALF) + z
    if err > max_sqrt_error:
        max_sqrt_error = err
    if (Indx == 1) or (Indx == 3):
        x = ulp * Sign (x) * FLOOR(EIGHT / (NINE * SQRT(ulp)))
    else:
        ulp = ULP_OF_ONE_MINUS
        x = - ulp
    print("post loop test")
    print("min_sqrt_error = {:0.17e}".format(min_sqrt_error))
    print("max_sqrt_error = {:0.17e}".format(max_sqrt_error))
print("post speecial cases")
print("min_sqrt_error = {:0.17e}".format(min_sqrt_error))
print("max_sqrt_error = {:0.17e}".format(max_sqrt_error))

milestone = 85   #==============================
def SR3750():
    """Test utility."""
    global I, X2, y2, SqEr, min_sqrt_error, max_sqrt_error
    if not ((x - B < z2 - B) or (x - z2 > BIG_B_NTH - z2)):
        I = I + 1
        X2 = SQRT(x * D)
        y2 = (X2 - z2) - (y - z2)
        X2 = X8 / (y - ONE_HALF)
        X2 = X2 - ONE_HALF * X2 * X2
        SqEr = (y2 + ONE_HALF) + (ONE_HALF - X2)
        if SqEr < min_sqrt_error:
            min_sqrt_error = SqEr
        SqEr = y2 - X2
        if SqEr > max_sqrt_error:
            max_sqrt_error = SqEr
        return


def NewD():
    """Test utility."""
    global x, Q, z, z1, D
    x = z1 * Q
    x = FLOOR(ONE_HALF - x / B) * B + x
    Q = (Q - x * z) / B + x * x * (D / B)
    z = z - TWO * x * D
    if z <= ZERO:
        z = - z
        z1 = - z1
    D = B * D
    return


SqRWrng = False
Anomaly = False
flags["sqrt_rounding"] = "other"
if B != ONE:
    print("Testing whether sqrt is rounded or chopped.")
    D = FLOOR(ONE_HALF + POW(B, ONE + PRECISION - FLOOR(PRECISION)))
    # ... == B^(1 + fract) if (PRECISION == Integer + fract.
    x = D / B
    y = D / A
    if (x != FLOOR(x)) or (y != FLOOR(y)):
        Anomaly = True

    else:
        x = ZERO
        z2 = x
        y = ONE
        y2 = y
        z1 = B - ONE
        FourD = FOUR * D
        doit = True
        while doit:
            if (y2 > z2):
                Q = B
                y1 = y
                doit2 = True
                while doit2:
                    x1 = FABS(Q + FLOOR(ONE_HALF - Q / y1) * y1)
                    Q = y1
                    y1 = x1
                    doit2 = not (x1 <= ZERO)
                if (Q <= ONE):
                    z2 = y2
                    z = y
            y = y + TWO
            x = x + EIGHT
            y2 = y2 + x
            if y2 >= FourD:
                y2 = y2 - FourD
            doit = not (y >= D)
        X8 = FourD - z2
        # ***JTC: fix global Q used by NewD
        Q = (X8 + z * z) / FourD
        X8 = X8 / EIGHT
        if Q != FLOOR(Q):
            Anomaly = True
        else:
            Break = False
            doit = True
            while doit:
                x = z1 * z
                x = x - FLOOR(x / B) * B
                if x == ONE:
                    Break = True
                else:
                    z1 = z1 - ONE
                doit = not (Break or (z1 <= ZERO))
            if (z1 <= ZERO) and (not Break):
                Anomaly = True
            else:
                if z1 > B_OVER_TWO:
                    z1 = z1 - B
                doit = True
                while doit:
                    NewD()
                    doit = not (ULP_OF_ONE_PLUS * D >= ONE_MINUS_ULP)
                if D * B - D != BIG_B_NTH - D:
                    Anomaly = True
                else:
                    z2 = D
                    I = 0
                    y = D + (ONE + z) * ONE_HALF
                    x = D + z + Q
                    SR3750()
                    y = D + (ONE - z) * ONE_HALF + D
                    x = D - z + D
                    x = x + Q + x
                    SR3750()
                    NewD()
                    if D - z2 != BIG_B_NTH - z2:
                        Anomaly = True
                    else:
                        y = (D - z2) + (z2 + (ONE - z) * ONE_HALF)
                        x = (D - z2) + (z2 - z + Q)
                        SR3750()
                        y = (ONE + z) * ONE_HALF
                        x = Q
                        SR3750()
                        if I == 0:
                            Anomaly = True

    if ((I == 0) or Anomaly):
        BadCond(err_failure, "Anomalous arithmetic with Integer < ")
        print("B^PRECISION = {:0.7e}".format(BIG_B_NTH))
        print(" fails test whether sqrt rounds or chops.")
        SqRWrng = True

print("post final test")
print("min_sqrt_error = {:0.17e}".format(min_sqrt_error))
print("max_sqrt_error = {:0.17e}".format(max_sqrt_error))

if not Anomaly:
    if not ((min_sqrt_error < ZERO) or (max_sqrt_error > ZERO)):
        flags["sqrt_rounding"] = "rounded"
        print("Square root appears to be correctly rounded.")
    else :
        if (max_sqrt_error + ULP_OF_ONE_PLUS > ULP_OF_ONE_PLUS - ONE_HALF) or (min_sqrt_error > ONE_HALF)\
                or (min_sqrt_error + B < ONE_HALF):
            SqRWrng = True
        else:
            flags["sqrt_rounding"] = "chopped"
            print("Square root appears to be chopped.")

if (SqRWrng):
    print("Square root is neither chopped nor correctly rounded.")
    print("Observed errors run from {:0.7e} ".format(min_sqrt_error - ONE_HALF),
          end="")
    print("to {:0.7e} ulps.".format(ONE_HALF + max_sqrt_error))
    TstCond(err_serious, max_sqrt_error - min_sqrt_error < B * B,
        "sqrt gets too many last digits wrong")

milestone = 90   #==============================
Pause()
print("Testing powers z^i for small Integers z and i.")
err_cnt = 0
# ... test powers of zero.
# If(-1)^k is invalid, replace MINUS_ONE by ONE.
# JTC: M = 3 was the max value of I, but was it supposed to be a count?
for (z, i) in [(-ZERO, 0), (MINUS_ONE, -4)]:
    x = ONE
    test_integer_powers(x, z, 0, 3)
    # For higher odd powers z is the starting value of x.
    test_integer_powers(z, z, 1023, 1026)

print_if_err_cnt_positive()
N1 = err_cnt
err_cnt = 0
m = int(FLOOR(TWO * LOG(BIG_B_NTH) / LOG(A)))
for z in [A, ONE_OVER_A]:   # Executes 2x if A = 1/A
    test_integer_powers(z, z, 1, m)

milestone = 100   #==============================
# Powers of B have been tested, sonext try a few primes.
# The simpler loop skips the trick of stepping by 2 through the odd
# numbers from 3, filtering the further multiples of 3.
m = NUM_TRIALS
for z in [3, 5, 7, 11, 13, 17, 19, 23]:
    test_integer_powers(z, z, 1, m)
if err_cnt > 0:
    print("Errors like this may invalidate financial calculations")
    print("\tinvolving interest rates.")

print_if_err_cnt_positive()
err_cnt += N1
if err_cnt == 0:
    print("... no discrepancies found.")
if err_cnt > 0:
    Pause()
else:
    print("")
