#! /usr/bin/python
# File paranoia.py drives the paranoia test. Execute this fie.

from __future__ import division         # use // for integer division

import math

#
#        A Python version of Kahan's Floating Point Test "Paranoia"
#
#                Jerome Coonen, Nov 2019
#
#        This is a rewrite of the C version by
#
#                Thos Sumner, UCSF, Feb. 1985
#                David Gay, BTL, Jan. 1986
#
#        itself a rewrite from the Pascal version by
#
#                B. A. Wichmann, 18 Jan. 1985
#
#    It is Pythonic where possible, while adhering as closely as
#    possible to its BASIC roots.
#
#    (C) Apr 19 1983 in BASIC version by:
#        Professor William M. Kahan,
#        EECS Dept., Room 441
#        Soda Hall
#        University of California
#        Berkeley, California 94720
#        USA
#
#    converted to Pascal by:
#        B. A. Wichmann
#        National Physical Laboratory
#        Teddington Middx
#        TW11 OLW
#        UK
#
#    converted to C by:
#        David M. Gay             Thos Sumner
#        AT&T Bell Labs           Computer Center, Rm. U-76
#        600 Mountain Avenue      University of California
#        Murray Hill, NJ 07974    San Francisco, CA 94143
#        USA                      USA
#
#    converted to Python by:
#         Jerome Coonen
#         jcoonen@gmail.com
#
#    Comments on the Python conversion:
#    To be completed...
#
#
#    The following is from the introductory commentary to Sumner and Gay's work:
#
#    The conversion to C is made with simultaneous corrections to the
#    Pascal source (reflected in the Pascal source available over netlib).
#    [A couple of bug fixes from dgh = sun!dhough incorporated 31 July 1986.]
#
#    Reports of results on various systems from all the versions
#    of Paranoia are being collected by Richard Karpinski at the
#    same address as Thos Sumner.  This includes sample outputs,
#    bug reports, and criticisms.
#
#    You may copy this program freely if you acknowledge its source.
#    Comments on the Pascal version to NPL, please.
#
#    The C version catches signals from floating-point exceptions.
#    If signal(SIGFPE,...) is unavailable in your environment, you may
#    #define NOSIGNAL to comment out the invocations of signal.
#
#    This source file is too big for some C compilers, but may be split
#    into pieces.  Comments containing "SPLIT" suggest convenient places
#    for this splitting.  At the end of these comments is an "ed script"
#    (for the UNIX(tm) editor ed) that will do this splitting.
#
#    By #defining Single when you compile this source, you may obtain
#    a single-precision C version of Paranoia.
#
#
#    The following is from the introductory commentary from Wichmann's work:
#
#    The BASIC program of Kahan is written in Microsoft BASIC using many
#    facilities which have no exact analogy in Pascal.  The Pascal
#    version below cannot therefore be exactly the same.  Rather than be
#    a minimal transcription of the BASIC program, the Pascal coding
#    follows the conventional style of block-structured languages.  Hence
#    the Pascal version could be useful in producing versions in other
#    structured languages.
#
#    Rather than use identifiers of minimal length (which therefore have
#    little mnemonic significance), the Pascal version uses meaningful
#    identifiers as follows [Note: A few changes have been made for C]:
#
#  BASIC   C               BASIC   C               BASIC   C
#
#   A                       J                       S    StickyBit
#   A1   AInvrse           J0   NoErrors           T
#   B    Radix                    [Failure]         T0   Underflow
#   B1   BInverse           J1   NoErrors           T2   ThirtyTwo
#   B2   RadixD2                  [SeriousDefect]   T5   OneAndHalf
#   B9   BMinusU2           J2   NoErrors           T7   TwentySeven
#   C                             [Defect]          T8   TwoForty
#   C1   CInverse           J3   NoErrors           U    OneUlp
#   D                             [Flaw]            U0   UnderflowThreshold
#   D4   FourD              K    PageNo             U1
#   E0                      L    Milestone          U2
#   E1                      M                       V
#   E2   Exp2               N                       V0
#   E3                      N1                      V8
#   E5   MinSqEr            O    Zero               V9
#   E6   SqEr               O1   One                W
#   E7   MaxSqEr            O2   Two                X
#   E8                      O3   Three              X1
#   E9                      O4   Four               X8
#   F1   MinusOne           O5   Five               X9   Random1
#   F2   Half               O8   Eight              X
#   F3   Third              O9   Nine               Y1
#   sixth                      P    Precision          Y2
#   F9                      Q                       Y9   Random2
#   G1   GMult              Q8                      Z
#   G2   GDiv               Q9                      Z0   PseudoZero
#   G3   GAddSub            R                       Z1
#   H                       R1   RMult              Z2
#   H1   HInverse           R2   RDiv               Z9
#   I                       R3   RAddSub
#   IO   NoTrials           R4   RSqrt
#   I3   IEEE               R9   Random9
#
#   SqRWrng
#
#    All the variables in BASIC are true variables and in consequence,
#    the program is more difficult to follow since the "constants" must
#    be determined (the glossary is very helpful).  The Pascal version
#    uses Real constants, but checks are added to ensure that the values
#    are correctly converted by the compiler.
#
#    The major textual change to the Pascal version apart from the
#    identifiersis that named procedures are used, inserting parameters
#    wherehelpful.  New procedures are also introduced.  The
#    correspondence is as follows:
#
#    BASIC       Pascal
#    lines
#
#      90- 140   Pause
#     170- 250   Instructions
#     380- 460   Heading
#     480- 670   Characteristics
#     690- 870   History
#    2940-2950   Random
#    3710-3740   NewD
#    4040-4080   DoesYequalX
#    4090-4110   PrintIfNPositive
#    4640-4850   TestPartialUnderflow

#----START CODE----

# Integer constants
NUM_TRIALS = 20   # Number of tests for commutativity.

# Declarations of global variables
err_failure = 0
err_serious = 1
err_defect = 2
err_flaw = 3
error_count = [0, 0, 0, 0]
error_type = ["Failure", "Serious", "Defect", "Flaw"]
fpecount = 0   # int
milestone = 0   # int
PageNo = 0   # int
M = 0   # int
err_cnt = 0   # int
N1 = 0   # int
rand_seed = math.nan
rand_next = math.nan
min_sqrt_error = math.nan
max_sqrt_error = math.nan

flags = {
    "mult_guard_digit": False,
    "div_guard_digit": False,
    "add_sub_guard_digit": False,
    "mult_rounding": "other",
    "div_rounding": "other",
    "add_sub_rounding": "other",
    "sqrt_rounding": "other",
    "uses_sticky_bit": False,
    "IEEE": False
}

Break= False
Done= False
NotMonot= False
Monot= False
Anomaly= False
IEEE= False
SqRWrng= False


#    START MESSAGES
#    Block messages to be printed as the user starts running paranoia.

def msglist(s):
    """Print a list of strings"""
    for m in s:
        print(m)

def Instructions():
    """Self-explanatory user instructions"""
    instr = [
        "Lest this program stop prematurely, i.e. before displaying\n",
        "    `END OF TEST',\n",
        "try to persuade the computer NOT to terminate execution when an",
        "error like Over/Underflow or Division by Zero occurs, but rather",
        "to persevere with a surrogate value after, perhaps, displaying some",
        "warning.  If persuasion avails naught, don't despair but run this",
        "program anyway to see how many milestones it passes, and then",
        "amend it to make further progress.\n",
        "Answer questions with Y y, N or n (unless otherwise indicated).\n"
    ]
    msglist(instr)

def Heading():
    """Gives user a place to report issues."""
    head = [
        "Users are invited to help debug and augment this program so it will",
        "cope with unanticipated and newly uncovered arithmetic pathologies.\n",
        "Please send suggestions and interesting results to",
        "\tJerome Coonen",
        "\tjcoonen@gmail.com\n",
        "In doing so, please include the following information:",
        "\tPrecision:\tdouble;",
        "\tVersion:\t10.py February 2020;",
        "\tComputer:",
        "\tCompiler:",
        "\tOptimization level:",
        "\tOther relevant compiler options:"
    ]
    msglist(head)

def Characteristics():
    """Explain whtat the program reveals"""
    chars = [
        "Running this program should reveal these characteristics:",
        "     Radix B = 1, 2, 4, 8, 10, 16, 100, 256 ...",
        "     PRECISION = number of significant digits carried.",
        "     ULP_OF_ONE_PLUS = B/B^PRECISION = One Ulp",
        "         (Unit in the Last Place) of 1.000xxx .",
        "     ULP_OF_ONE_MINUS = 1/B^PRECISION = One Ulp",
        "          of numbers a little less than 1.0 .",
        "     Adequacy of guard digits for Mult., Div. and Subt.",
        "     Whether arithmetic is chopped, correctly rounded, or something else",
        "         for Mult., Div., Add/Subt. and Sqrt.",
        "     Whether a Sticky Bit used correctly for rounding.",
        "     UnderflowThreshold = an underflow threshold.",
        "     E0 and too_tiny_x tell whether underflow is abrupt, gradual, or fuzzy.",
        "     V = an overflow threshold, roughly.",
        "     V0  tells, roughly, whether  Infinity  is represented.",
        "     Comparisions are checked for consistency with subtraction",
        "         and for contamination with pseudo-zeros.",
        "     Sqrt is tested.  Y^X is tested for integer X.",
        "     Extra-precise subexpressions are revealed but NOT YET tested.",
        "     Decimal-Binary conversion is NOT YET tested for accuracy."
     ]
    msglist(chars)

def History():
    """Tell the story of paranoia
    Converted from Brian Wichmann's Pascal version to C by Thos Sumner,
    with further massaging by David M. Gay.
    Converted from the Sumner-Gay C version to Python by Jerome Coonen
    """
    hist = [
        "The program attempts to discriminate among",
        "   FLAWs, like lack of a sticky bit,",
        "   Serious DEFECTs, like lack of a guard digit, and",
        "   FAILUREs, like 2+2 == 5 .",
        "Failures may confound subsequent diagnoses.",
        "\nThe diagnostic capabilities of this program go beyond an earlier",
        "program called `MACHAR', which can be found at the end of the",
        "book  `Software Manual for the Elementary Functions' (1980) by",
        "W. J. Cody and W. Waite. Although both programs try to discover",
        "the radix, precision, and range (over/underflow thresholds)",
        "of the arithmetic, this program tries to cope with a wider variety",
        "of pathologies, and to say how well the arithmetic is implemented.",
        "\nThe program is based upon a conventional radix representation for",
        "floating-point numbers, but also allows logarithmic encoding",
        "as used by certain early WANG machines.\n",
        "BASIC version of this program (C) 1983 by Prof. W. M. Kahan;",
        "see source comments for more history."
    ]
    msglist(hist)


#----START SUBROUTINES----
def notify(s):
	print("{:s} test appears to be inconsistent...".format(s))
	print("   PLEASE NOTIFY COONEN!\n")

def FABS(x):
    return math.fabs(x)

def FLOOR(x):
    return math.floor(x)

def LOG(x):
    return math.log(x)

def POW(x,y):
    return math.pow(x,y)

def SQRT(x):
    return math.sqrt(x)

def Sign(x):
    """+1.0 for a nonnegative argument, else -1.0"""
    return 1.0 if x >= 0 else -1.0

def Pause():
    """Wait until the user hits RETURN"""
    global milestone, PageNo
    s = input("\nTo continue, press RETURN ")
    print("\nDiagnosis resumes after milestone Number ", milestone,
          "          Page: ", PageNo, "\n")
    milestone += 1   # note -- milestone may be changed by extra pauses
    PageNo += 1

def TstCond(K, Valid, t):
    """Respond to a logical test
        K is level of error, Valid is the condition tested, t is a message"""
    if (not Valid):
        BadCond(K,t)
        print(".\n")

def BadCond(K, t):
    """Error message"""
    print("BadCond called with problem " + str(K))
    error_count[K] += 1
    print(error_type[K] + ":  " + t, end="")

def rand_frac():
    """Generatre random fractions.

        Compute x = (rand_next + rand_seed)^5
        rand_next = x - FLOOR(x) + 0.000005 * x
        Globals rand_next and rand_seed are initialized when needed.
        Returns the new value of rand_next
    """
    global rand_next, rand_seed
    x = rand_next + rand_seed
    y = x * x
    y = y * y
    x = x * y
    y = x - math.floor(x)
    rand_next = y + x * 0.000005
    return rand_next


def print_if_err_cnt_positive():
    '''Print an error message from a global count.'''
    global err_cnt
    if err_cnt > 0:
        print("Similar discrepancies have occurred {:d} times.".format(err_cnt))
    return


#=============================================
# Computations of fundamental system constants like radix and precisioon.
#=============================================
def find_big_two_to_the_nth():
    """Compute 2**n that dominates 1.0.

    Regardless of radix, find the smallest 2**n such that
    |((2**n + 1)-2**n)-1| >= 1.  This value will be used for the first
    evaluation of the radix.  For small n, the sum is just zero.  When n is
    so large that the 2**n has no ones place, the sum with 1 will round
    down to 2**n or up to (2**n + 2), hence the absolute value.

     Returns:
         Smallest 2**n satisfying the formula above.
    """
    x = ONE
    while True:
        x = x + x
        y = x + ONE
        z = y - x
        y = z - ONE
        if MINUS_ONE + FABS(y) >= ZERO: break   # ***JTC: new style loop
        # ... now x is just big enough that |((x+1)-x)-1| >= 1 ...
    return x


def find_radix_from_2_nth(big):
    """Look for a carry out of the ones place.

    Arguments;
        big satisfies |((big + 1) - big) - 1| >= 1

    Returns:
        radix, which may not be integral in log arithmetic
    """
    y = ONE
    doit = True
    while doit:
        b = big + y
        y = y + y
        b = b - big
        doit = b == ZERO
    return b


def find_precision_big_B_nth(b):
    """Compute the number of B-digits in the arithmetic and the power
    of B sufficient to have the ones place fall off the right.

    Args:
        b: radix
    Returns:
        precision: number of B digits
        power of B such that the low-order digit is the B's place.
    """

    big_b = ONE
    precision = ZERO
    doit = True
    while doit:
        precision = precision + ONE
        big_b = big_b * b
        y = big_b + ONE
        doit = (y - big_b) == ONE
    return precision, big_b


def find_ulp_of_one_plus(guess):
    """Compute value by iterating down to a single ulp.

    Args:
        guess: default guess for 1 ulp of value just over 1

    Returns:
        the value u such at 1+u is the next larger value than 1
    """

    x = FOUR / THREE    # rounds in ulps of 1
    third = x - ONE
    sixth = ONE_HALF - third
    x = sixth + sixth
    x = FABS(x - third)
    if x < guess:
        x = guess
    # Now x = (unknown no.) ulps of 1+.
    doit = True
    while doit:
        u = x
        y = ONE_HALF * u + THIRTY_TWO * u * u
        y = ONE + y
        x = y - ONE
        doit = (u > x) and (x > ZERO)
    return u


def find_ulp_of_one_minus(guess):
    """Compute value by iterating down to a single ulp.

    Args:
        guess: default guess for 1 ulp of value just under 1

    Returns:
        the value u such at 1 - u is the next smaller value than 1
    """

    x = TWO / THREE
    sixth = x - ONE_HALF
    third = sixth + sixth
    x = third - ONE_HALF
    x = FABS(x + sixth)
    if (x < guess):
        x = guess
    # Now  x == (unknown no.) ulps of 1 -.
    doit = True
    while doit:
        u = x
        y = ONE_HALF * u + THIRTY_TWO * u * u
        y = ONE_HALF - y
        x = ONE_HALF + y
        y = ONE_HALF - x
        x = ONE_HALF + y
        doit = (u > x) and (x > ZERO)
    return u


def compute_A_and_inverse(radix):
    """Return value for constants A and ONE_OVER_A, based on radix.

    a is 2 if radix is 1 (***logarithmic?) or a  power of 2.
    a is 10 if radix is a power of 10. Otherwise a is the radix.
    There are two tests that value "a" behaves well in division.

    Args:
        radix -- usually passed from B

    Returns:
        a, 1 / a
    """

    a = radix   # Default to the unusual case
    for z in [TWO, NINE+ONE]:
        y = radix
        doit = True
        while doit:
            x = y
            y = y / z
            doit = FLOOR(y) == y
        if x == ONE:
            a = z   # Have found a power of 2 or 10
            break
    one_over_a = ONE / a
    x = a
    y = one_over_a
    for x in [a, B]:
        y = ONE / x
        z = x * y - ONE_HALF
        TstCond(err_failure, z == ONE_HALF, "x * (1/x) differs from 1")
    return a, one_over_a


def compute_C_and_inverse():
    """Return untility constant C = 1 / B**k, k farther than PRECISION
    from causing underflow.

    C is a useful starting point for investigation of underflow.
    It has the form 1 / B**k with k chosen so that C is fartther than
    a factor of 1 / B**PRECISION of underflowing to zero.
    C is a normal number. It's reciprocal is a large power of B.

    Returns:
        C, 1 / C
    """
    d = ULP_OF_ONE_MINUS   # default value for integer precision
    if PRECISION != FLOOR(PRECISION):
        # Compute 1 / B**ceiling(PRECISION)
        d = ONE_OVER_B
        for _ in range(FLOOR(PRECISION)):
            d = d * ONE_OVER_B
    # d = 1 / B**k for k = PRECISION or FLOOR(PRECISION)+1
    # Compute 1/d * 1/d**2 * 1/d**4 * ... until the multiplier
    # tapers off (due to underflow). This is the quick route to
    # a very tiny 1 / B**k in ever-inceasing steps.
    y = ONE
    z = d
    while True:
        c = y
        y = z
        z = y * y
        if (y <= z) or (z + z <= z): break
    # Finally, step toward the minimum normal number by multiples of d.
    # c stays one step behind y, so that at termination
    # 1  >>  c  >  2**(min+PRECISION)  >  y  >  2**mnin  >  z (underflows)
    y = c
    z = y * d
    while True:
        c = y
        y = z
        z = y * d
        if (y <= z) or (z + z <= z): break
    return c, ONE / c


def compute_SAFE_ULPS_OF_ONE():
    """Return a value useful in over/underflow testing.

    Want to find x such that (1+x)*some_power_of_B leaves some low bits,
    so that the product exceeds C, a power of B not far from the underflow
    threshold. Try x = 1 ulp, but settle for B ulps of, whether or not it
    works.

    Returns:
        1 or B ulps of one
    """

    x= ULP_OF_ONE_PLUS
    s = ONE + x
    # C is far enough above the underflow threshold that there should be no
    # total loss of low digits when multiplied by s.
    d = C * s
    if d <= C:
        # Lack of a guard bit in binary could lose one bit, so try B digits
        # in a more lenient value of SAFE_ULPS_OF_ONE.
        x = B * ULP_OF_ONE_PLUS
    return x


def compute_H_and_inverse():
    """Return min(1/B, 1/2) and reciprocal, noting H is a fraction."""
    if B < TWO:
        h_inv = TWO
    else:
        h_inv = B
    return ONE / h_inv, h_inv


def standardize_fractional_precision(ulp, b):
    """Return the precision standardized so that any franction part
     is in units of 1/240. The factors of 240 = 3*5*16 ensures
     that fractional octal, decimal, or hex digits will be handled
     properly.

    Args:
        ulp -- unit in the last place of a value just less than 1
        b -- radix
    Returns:
         sss
    """

    # Intuitively, ulp = b**(-precisioon), so the negative of the
    # ratio of the logs retrieves the precision. But there may be
    # extra bits in octal or hex or even decimal, making up a partial
    # lowest-order digit. The factor 240 is a multiple of 8, 10, and
    # 16 with a bit extra. The value y rounds off noise from the logs.
    # TODO: resolve the apparent redundancy between the big factor 240
    # and the check for being with a quarter.
    x = - TWOFORTY * LOG(ulp) / LOG(b)
    y = FLOOR(ONE_HALF + x)
    if (FABS(x - y) * FOUR < ONE):
        x = y
    p = x / TWOFORTY
    y = FLOOR(ONE_HALF + p)
    if (FABS(p - y) * TWOFORTY < ONE_HALF):
        p = y
    return p

#=============================================
# Test for extra precison.
#=============================================
def test_for_extra_precise_subepressions():
    """Print messages if wider intermediate values detected.

    """

    # (4/3 -1) - 1/4 = 1/12 with rounding error in values bigger than 1.
    # 3 * rounded value - 1/4 should be some rounding error in 1+.
    # z2 should be an ulp of 1+, unless the computation of x below enjoys
    # extra precision, allowing it to be even smaller.
    x = FABS(((FOUR / THREE - ONE) - ONE / FOUR) * THREE - ONE / FOUR)
    doit = True
    while doit:
        z2 = x
        x = (ONE + (ONE_HALF * z2 + THIRTY_TWO * z2 * z2)) - ONE
        doit =  (z2 > x) and (x > ZERO)

    # Now look at ulps of 1- by starting with rounding noise in 3/4.
    # x, y, and z are used in the three following loops.
    x = y = z = FABS((THREE / FOUR - TWO / THREE) * THREE - ONE / FOUR)
    while True:
        z1 = z
        z = (ONE / TWO
             - ((ONE / TWO - (ONE_HALF * z1 + THIRTY_TWO * z1 * z1))
                + ONE / TWO)) + ONE / TWO
        if (z1 <= z) or (z <= ZERO): break
    # BUG in BASIC and C version -- the two loops below are not nested,
    # but simply in sequence with the z1 loop just above.
    # See lines 1730 and 1740 in the BASIC, the latter line should branch
    # back to itself.
    while True:
        y1 = y
        y = (ONE_HALF - ((ONE_HALF - (ONE_HALF * y1 + THIRTY_TWO * y1 * y1))
                         + ONE_HALF)) + ONE_HALF
        print("1730: y1 = {:.17e} y = {:.17e}".format(y1, y))
        if  (y1 <= y) or (y <= ZERO): break
    while True:
        x1 = x
        x = ((ONE_HALF * x1 + THIRTY_TWO * x1 * x1)
             - ONE_MINUS_ULP)+ ONE_MINUS_ULP
        print("1740: x1 = {:.17e} x = {:.17e}".format(x1, x))
        if  (x1 <= x) or (x <= ZERO): break
    if (x1 != y1) or (x1 != z1):
        BadCond(err_serious, "Disagreements among the values x1, y1, z1,")
        print("respectively  {:0.7e},  {:0.7e},  {:0.7e},".format(x1, y1, z1))
        print("are symptoms of inconsistencies introduced")
        print("by extra-precise evaluation of arithmetic subexpressions.")
        notify("Possibly some part of this")
        if ((x1 == ULP_OF_ONE_MINUS) or (y1 == ULP_OF_ONE_MINUS)
                or (z1 == ULP_OF_ONE_MINUS)):
            print("That feature is not tested further by this program.\n")

    elif (z1 != ULP_OF_ONE_MINUS) or (z2 != ULP_OF_ONE_PLUS):
        if (z1 >= ULP_OF_ONE_MINUS) or (z2 >= ULP_OF_ONE_PLUS):
            BadCond(err_failure, "")
            notify("PRECISION")
            print("\tULP_OF_ONE_MINUS = {:0.7e}, z1 - ULP_OF_ONE_MINUS = {:0.7e}".format(ULP_OF_ONE_MINUS,z1-ULP_OF_ONE_MINUS))
            print("\tULP_OF_ONE_PLUS = {:0.7e}, z2 - ULP_OF_ONE_PLUS = {:0.7e}".format(ULP_OF_ONE_PLUS,z2-ULP_OF_ONE_PLUS))
        else:
            if ((z1 <= ZERO) or (z2 <= ZERO)):
                print("Because of unusual B = {:0.f}".format(B))
                print(", or exact rational arithmetic a result")
                print("z1 = {:0.7e}, or z2 = {:0.7e} ".format(z1, z2))
                notify("of an extra-precision")

            if z1 != z2 or z1 > ZERO:
                x = z1 / ULP_OF_ONE_MINUS
                y = z2 / ULP_OF_ONE_PLUS
                if y > x:
                    x = y
                q = - LOG(x)
                print("Some subexpressions appear to be calculated extra")
                print("precisely with about {:.g} extra B-digits, i.e.",
                    (q / LOG(B)))
                print("roughly {:.g} extra significant decimals.".
                    format(q / LOG(10.)))
            print("That feature is not tested further by this program.")


#=============================================
# Tests for normalization, guard digit, rounding, use of a sticky bit.
#=============================================
def test_normalized_subtraction():
    """Test for renormalization on magnitude subtraction.

    Computes 1.0 via cancellation of two large values. Then adds
    a tiny increment that would be rounded off were the value 1.0
    not normalized after the subtraction.
    """
    if (B >= TWO):
        x = BIG_B_NTH / (B * B)
        y = x + ONE
        z = y - x
        t = z + ULP_OF_ONE_PLUS
        x = t - z
        if x == ULP_OF_ONE_PLUS:
            print("Subtraction appears to be normalized, as it should be.")
        else:
            TstCond(err_failure, False,
                    "Subtraction is not normalized x=y,x+z != y+z!")
        return


def does_mult_have_guard_digit():
    """Test for a guard digit in mulitiplicaiton.

    Run three tests, 1*X and X*1 for X with nonzero low-order
    digit, and a product known to require one extra digit, before
    normalization.

    Returns:
        boolean answer to the question
    """
    print("\nChecking for guard digit in *, /, and -.")
    y = ONE_MINUS_ULP * ONE
    z = ONE * ONE_MINUS_ULP
    x = ONE_MINUS_ULP - ONE_HALF
    y = (y - ONE_HALF) - x
    z = (z - ONE_HALF) - x
    x = ONE + ULP_OF_ONE_PLUS
    t = x * B
    r = B * x
    x = t - B
    x = x - B * ULP_OF_ONE_PLUS
    t = r - B
    t = t - B * ULP_OF_ONE_PLUS
    x = x * (B - ONE)
    t = t * (B - ONE)
    gmult = (x == ZERO) and (y == ZERO) and (z == ZERO) and (t == ZERO)
    TstCond(err_serious, gmult, "* lacks a Guard Digit, so 1*x != x")
    return gmult


def test_mult_low_digits():
    """Try two tests of the form (1 + tiny)**2."""
    z = B * ULP_OF_ONE_PLUS
    x = ONE + z
    y = FABS((x + z) - x * x) - ULP_OF_ONE_PLUS
    x = ONE - ULP_OF_ONE_PLUS
    z = FABS((x - ULP_OF_ONE_PLUS) - x * x) - ULP_OF_ONE_MINUS
    TstCond(err_failure, y <= ZERO and z <= ZERO,
            "* gets too many final digits wrong.\n")


def does_div_have_guard_digit():
    """Check for guard digit in division.

    Returns:
        boolean reply to question
    """
    y = ONE - ULP_OF_ONE_PLUS
    x = ONE + ULP_OF_ONE_PLUS
    z = ONE / y
    y = z - x
    x = ONE / THREE
    z = THREE / NINE
    x = x - z
    t = NINE / TWENTY_SEVEN
    z = z - t
    gdiv = (x == ZERO) and (y == ZERO) and (z == ZERO)
    TstCond(err_defect, gdiv,
            "Division lacks a Guard Digit, so error can exceed 1 ulp\n"
            + "or  1/3  and  3/9  and  9/27 may disagree")
    y = ONE_MINUS_ULP / ONE
    x = ONE_MINUS_ULP - ONE_HALF
    y = (y - ONE_HALF) - x
    x = ONE + ULP_OF_ONE_PLUS
    t = x / ONE
    x = t - x
    # JTC: gdiv now includes all 5 tests not just last 4 like original.
    gdiv &= (x == ZERO) and (y == ZERO)
    TstCond(err_serious, gdiv, "Division lacks a Guard Digit, so x/1 != x")
    return gdiv


def does_add_sub_have_guard_digit():
    """Check for guard digit in add and subtract.

    Returns:
        boolean reply to question
    """
    x = ONE / (ONE + ULP_OF_ONE_PLUS)
    y = x - ONE_HALF - ONE_HALF
    TstCond(err_serious, y < ZERO, "Computed value of 1/1.000..1 >= 1")
    x = ONE - ULP_OF_ONE_PLUS
    y = ONE + B * ULP_OF_ONE_PLUS
    z = x * B
    t = y * B
    r = z / B
    s = t / B
    x = r - x
    y = s - y
    TstCond(err_failure, x == ZERO and y == ZERO,
            "* and/or / gets too many last digits wrong")
    y = ONE - ULP_OF_ONE_MINUS
    x = ONE - ONE_MINUS_ULP
    y = ONE - y
    t = B - ULP_OF_ONE_PLUS
    z = B - B_MINUS_ULP
    t = B - t
    gaddsub = ((x == ULP_OF_ONE_MINUS) and (y == ULP_OF_ONE_MINUS)
               and (z == ULP_OF_ONE_PLUS) and (t == ULP_OF_ONE_PLUS))
    TstCond(err_serious, gaddsub,
            "- lacks Guard Digit, so cancellation is obscured")
    return gaddsub


def how_does_mult_round():
    """Check type of rounding in multiplication.

    Returns:
        "rounded", "chopped", "other"
    """
    rmult = "other"
    y2 = ONE + ULP_OF_ONE_PLUS
    y1 = ONE - ULP_OF_ONE_PLUS
    x = ONE_AND_HALF - ULP_OF_ONE_PLUS
    y = ONE_AND_HALF + ULP_OF_ONE_PLUS
    z = (x - ULP_OF_ONE_PLUS) * y2
    t = y * y1
    z = z - x
    t = t - x
    x = x * y2
    y = (y + ULP_OF_ONE_PLUS) * y1
    x = x - ONE_AND_HALF
    y = y - ONE_AND_HALF
    if ((x == ZERO) and (y == ZERO) and (z == ZERO) and (t <= ZERO)):
        x = (ONE_AND_HALF + ULP_OF_ONE_PLUS) * y2
        y = ONE_AND_HALF - ULP_OF_ONE_PLUS - ULP_OF_ONE_PLUS
        z = ONE_AND_HALF + ULP_OF_ONE_PLUS + ULP_OF_ONE_PLUS
        t = (ONE_AND_HALF - ULP_OF_ONE_PLUS) * y1
        x = x - (z + ULP_OF_ONE_PLUS)
        s1 = y * y1
        s = z * y2
        t = t - y
        y = (ULP_OF_ONE_PLUS - y) + s1
        z = s - (z + ULP_OF_ONE_PLUS + ULP_OF_ONE_PLUS)
        s1 = (y2 + ULP_OF_ONE_PLUS) * y1
        y1 = y2 * y1
        s1 = s1 - y2
        y1 = y1 - ONE_HALF
        if ((x == ZERO) and (y == ZERO) and (z == ZERO) and (t == ZERO)
            and ( s1 == ZERO) and (y1 == ONE_HALF)):
            rmult = "rounded"
            print("Multiplication appears to round correctly. ")
        elif ((x + ULP_OF_ONE_PLUS == ZERO) and (y < ZERO) and (z + ULP_OF_ONE_PLUS == ZERO)
                and (t < ZERO) and (s1 + ULP_OF_ONE_PLUS == ZERO)
                and (y1 < ONE_HALF)):
                rmult = "chopped"
                print("Multiplication appears to chop. ")
        else:
            print("* is neither chopped nor correctly rounded. ")
        if (rmult == "rounded"
                and not flags["mult_guard_digit"]):
            notify("Multiplication")
    else:
        print("* is neither chopped nor correctly rounded. ")
    return rmult


def how_does_div_round():
    """Check for rounding in division.

    Returns:
        "rounded", "chopped", "other"
    """
    rdiv = "other"
    y2 = ONE + ULP_OF_ONE_PLUS
    y1 = ONE - ULP_OF_ONE_PLUS
    z = ONE_AND_HALF + ULP_OF_ONE_PLUS + ULP_OF_ONE_PLUS
    x = z / y2
    t = ONE_AND_HALF - ULP_OF_ONE_PLUS - ULP_OF_ONE_PLUS
    y = (t - ULP_OF_ONE_PLUS) / y1
    z = (z + ULP_OF_ONE_PLUS) / y2
    x = x - ONE_AND_HALF
    y = y - t
    t = t / y1
    z = z - (ONE_AND_HALF + ULP_OF_ONE_PLUS)
    t = (ULP_OF_ONE_PLUS - ONE_AND_HALF) + t
    if not ((x > ZERO) or (y > ZERO) or (z > ZERO) or (t > ZERO)):
        x = ONE_AND_HALF / y2
        y = ONE_AND_HALF - ULP_OF_ONE_PLUS
        z = ONE_AND_HALF + ULP_OF_ONE_PLUS
        x = x - y
        t = ONE_AND_HALF / y1
        y = y / y1
        t = t - (z + ULP_OF_ONE_PLUS)
        y = y - z
        z = z / y2
        y1 = (y2 + ULP_OF_ONE_PLUS) / y2
        z = z - ONE_AND_HALF
        y2 = y1 - y2
        y1 = (ONE_MINUS_ULP - ULP_OF_ONE_MINUS) / ONE_MINUS_ULP
        if ((x == ZERO) and (y == ZERO) and (z == ZERO) and (t == ZERO)
                and (y2 == ZERO)  # BUG in C version: duplicate test
                and (y1 - ONE_HALF == ONE_MINUS_ULP - ONE_HALF)):
            rdiv = "rounded"
            print("Division appears to round correctly. ")
            if not flags["div_guard_digit"]:
                notify("Division")

        elif ((x < ZERO) and (y < ZERO) and (z < ZERO) and (t < ZERO)
              and (y2 < ZERO) and (y1 - ONE_HALF < ONE_MINUS_ULP - ONE_HALF)):
            rdiv = "chopped"
            print("Division appears to chop. ")
    if rdiv == "other":
        print("/ is neither chopped nor correctly rounded. ")
    return rdiv


def how_does_add_sub_round():
    """Check rounding on add/subtract.

    Returns:
        "rounded", "chopped", "other"
    """
    round_add_sub = "other"
    x = ONE - ULP_OF_ONE_MINUS * ULP_OF_ONE_MINUS
    y = ONE + ULP_OF_ONE_PLUS * (ONE - ULP_OF_ONE_PLUS)
    z = ONE_MINUS_ULP - ONE_HALF
    x = (x - ONE_HALF) - z
    y = y - ONE
    if (x == ZERO) and (y == ZERO):
        round_add_sub = "chopped"
        print("Add/Subtract appears to be chopped. ")
    while flags["add_sub_guard_digit"]:
        x = (ONE_HALF + ULP_OF_ONE_PLUS) * ULP_OF_ONE_PLUS
        y = (ONE_HALF - ULP_OF_ONE_PLUS) * ULP_OF_ONE_PLUS
        x = ONE + x
        y = ONE + y
        x = (ONE + ULP_OF_ONE_PLUS) - x
        y = ONE - y
        if (x != ZERO) or (y != ZERO): break

        x = (ONE_HALF + ULP_OF_ONE_PLUS) * ULP_OF_ONE_MINUS
        y = (ONE_HALF - ULP_OF_ONE_PLUS) * ULP_OF_ONE_MINUS
        x = ONE - x
        y = ONE - y
        x = ONE_MINUS_ULP - x
        y = ONE - y
        if (x != ZERO) or (y != ZERO): break
        if round_add_sub == "chopped":
            # ***JTC: BASIC 2690 sets R3 = F1 - O2*R3 triggering 3
            # messages when boch chopped and rounded are detected.
            round_add_sub = "other"
        else:
            round_add_sub = "rounded"
        print("Addition/Subtraction appears to round correctly. ")
        if not flags["add_sub_guard_digit"]:
            # ***JTC: BUG, annot happen, guard digit is checked above.
            notify("Add/Subtract")
        break   # Execute this block just once, with early exit possible.
    if round_add_sub == "other":  # pick up all the odd cases
        print("Addition/Subtraction neither rounds nor chops.")
    return round_add_sub


def rounding_symmetry_test():
    """Test sign symmetry in simple rounding case.

    Returns:
         True if passes, False otherwise
    """

    verdict = True
    x = ONE + ONE_HALF * (ONE + ONE_HALF)
    y = (ONE + ULP_OF_ONE_PLUS) * ONE_HALF
    z = x - y
    t = y - x
    s = z + t
    if (s != ZERO):
        verdict = False
        BadCond(err_flaw, "(x - y) + (y - x) is non zero!\n")
    return verdict


def has_sticky_bit():
    """Create a rounding situation designed to require a sticky bit.

    Returns:
        True if sticky detected, False otherwise
    """

    verdict = False
    x = (ONE_HALF + ULP_OF_ONE_MINUS) * ULP_OF_ONE_PLUS
    y = ONE_HALF * ULP_OF_ONE_PLUS
    z = ONE + y
    t = ONE + x
    if (z - ONE <= ZERO) and (t - ONE >= ULP_OF_ONE_PLUS):
        z = t + y
        y = z - x
        if (z - t >= ULP_OF_ONE_PLUS) and (y - t == ZERO):
            x = (ONE_HALF + ULP_OF_ONE_MINUS) * ULP_OF_ONE_MINUS
            y = ONE_HALF * ULP_OF_ONE_MINUS
            z = ONE - y
            t = ONE - x
            if (z - ONE == ZERO) and (t - ONE_MINUS_ULP == ZERO):
                z = (ONE_HALF - ULP_OF_ONE_MINUS) * ULP_OF_ONE_MINUS
                t = ONE_MINUS_ULP - z
                q = ONE_MINUS_ULP - y
                if ((t - ONE_MINUS_ULP == ZERO)
                        and (ONE_MINUS_ULP - ULP_OF_ONE_MINUS - q == ZERO)):
                    z = (ONE + ULP_OF_ONE_PLUS) * ONE_AND_HALF
                    t = (ONE_AND_HALF + ULP_OF_ONE_PLUS) - z + ULP_OF_ONE_PLUS
                    x = ONE + ONE_HALF / B
                    y = ONE + B * ULP_OF_ONE_PLUS
                    z = x * y
                    if (t == ZERO) and (x + B * ULP_OF_ONE_PLUS - z == ZERO):
                        if (B != TWO):
                            x = TWO + ULP_OF_ONE_PLUS
                            y = x / TWO
                            if (y - ONE) == ZERO:
                                verdict = True
                        else:
                            verdict = True
    return verdict


def test_mult_commutivity(count):
    """Run some random tests to check that x*y = y*x. """
    global rand_next, rand_seed
    rand_seed = SQRT(3.0)
    rand_next = ONE / THREE
    i = 0
    doit = True
    while doit:
        x = rand_frac()
        y = rand_frac()
        yx = y * x
        xy = x * y
        xyyx = xy - yx
        i = i + 1
        doit = (i < count) and (xyyx == ZERO)
    if (xyyx == ZERO):
        # One rather less random test lays out the operands, products,
        # and the computed difference.
        x = ONE + ONE_HALF / THREE
        y = (ULP_OF_ONE_PLUS + ULP_OF_ONE_MINUS) + ONE
        xy = x * y
        yx = y * x
        xyyx = ((ONE + ONE_HALF / THREE)
                * ((ULP_OF_ONE_PLUS + ULP_OF_ONE_MINUS) + ONE)
                - ((ULP_OF_ONE_PLUS + ULP_OF_ONE_MINUS) + ONE)
                * (ONE + ONE_HALF / THREE))
    # In the usual case, count random tests and 1 extra test are run.
    # xyyx is the final arbiter of success.
    if xyyx != ZERO:
        print("x * y == y * x fails for x = {:0.17e}  y = {:0.17e}"
              .format(x ,y))
        print("    x * y = {:0.17e}  y * x = {:0.17e}".format(xy, yx))
        print("    and x * y - y * x = {:0.17e}".format(xyyx))
        BadCond(err_defect, "x * y == y * x trial fails.")
    else:
        print("     No failures found in {:d} integer pairs.".format(count+1))


#=============================================
# Tests of square root accurcacy and monotonicity.
#=============================================
def is_x_sqrt_xx(x, ulp, error_kind):
    """Test x = sqrt(x*x), raise error if not, and track max and min
    signed error in units of ulp.

    Uses an artful decomposition of x into xa + xb to facilitate test for
    equality.
    ***TODO: elaborate that this decomposition is exact -- because the values
    of x all have trailing 0s?

    Args:
        x - value to be tested
        ulp - 1/2 ulp of argument x
        error_kind - level of alarm to raise

    Returns:
        True if x = sqrt(x*x), False otherwise
    """
    global min_sqrt_error, max_sqrt_error
    success = True
    xb = x * ONE_OVER_B
    xa = x - xb
    err = ((SQRT(x * x) - xb) - xa) / ulp
    if err != ZERO:
        success = False
        if err < min_sqrt_error:
            min_sqrt_error = err
        if err > max_sqrt_error:
            max_sqrt_error = err
        BadCond(error_kind, "\n")
        print("sqrt( {:0.17e}) - {:0.17e}  = {:0.17e}".format(x * x, x, ulp * err))
        print("\tinstead of correct value 0 .")
    return success


def test_sqrt_monotonicity():
    """Test for monotonicity around the radix B."""
    i = - 1
    x = B_MINUS_ULP
    y = B
    z = B + B * ULP_OF_ONE_PLUS   # B plus 1 ulp
    not_monot = False
    monot = False
    while not (not_monot or monot):
        i = i + 1
        x = SQRT(x)
        q = SQRT(y)
        z = SQRT(z)
        if (x > q) or (q > z):
            not_monot = True
        else:
            q = FLOOR(q + ONE_HALF)
            # B = q*q only if radix B is 16 or 4
            if (i <= 0) and (B != q * q):
                monot = True
            elif i <= 0:
                y = q
                x = y - ULP_OF_ONE_PLUS
                z = y + ULP_OF_ONE_PLUS
            elif i == 1:
                y = y * ONE_OVER_B
                x = y - ULP_OF_ONE_MINUS
                z = y + ULP_OF_ONE_MINUS
            else:
                # Have survived three cases
                monot = True
    if monot:
        print("sqrt has passed a test for Monotonicity.")
    else:
        BadCond(err_defect, "")
        print("sqrt(x) is non-monotonic for x near {:0.7e} .".format(y))


#=============================================
# Tests of X**K for integer X and K.
#=============================================


def test_power_result(x, z, q):
    """Check that x equals z**q, usually for exact integer cases."""
    global err_cnt
    y = POW(z, q)
    if y != x:
        if err_cnt <= 0:
            if z == ZERO and q <= ZERO:
                print("WARNING:  computing")
            else:
                BadCond(err_defect, "computing")
            print("\t({:0.17e}) ^ ({:0.17e})".format(z, q))
            print("\tyielded {:0.17e};\n".format(y))
            print("\twhich compared unequal to correct {:0.17e} ;".
                  format(x))
            print("\t\tthey differ by {:0.17e} .".format(y - x))
        err_cnt += 1   # ... count discrepancies.
    return


def test_integer_powers(x, z, i, max_i):
    """Test z**k for k = i .. max_i."""
    doit = True
    while doit:
        q = float(i)
        print("test_int_pow with x, z, q = {:.17e} {:.17e} {:.4f}".format(x, z, q))
        test_power_result(x, z, q)
        i += 1
        x = z * x
        # Stay within the range of exactly representable integers.
        doit = (x < BIG_B_NTH) and (i <= max_i)
    return


