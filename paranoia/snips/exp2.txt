milestone = 140   #==============================
print("")
# ...calculate Exp2 == exp(2) == 7.389056099...
x = ZERO
I = 2
y = TWO * THREE
q = ZERO
N = 0
doit = True
while doit:
    z = x
    I = I + 1
    y = y / (I + I)
    r = y + q
    x = z + r
    q = (z - x) + r
    doit = x > z
z = (ONE_AND_HALF + ONE / EIGHT) + x / (ONE_AND_HALF * THIRTY_TWO)
x = z * z
Exp2 = x * x
x = ONE_MINUS_ULP
y = x - ULP_OF_ONE_MINUS
print("Testing x^((x + 1) / (x - 1)) vs. " +
      "exp(2) = {:0.17e} as x -> 1.".format(Exp2))
I = 1
doit = True
while doit:
    z = x - ONE_OVER_B
    z = (x + ONE) / (z - (ONE - ONE_OVER_B))
    q = POW(x, z) - Exp2
    if (FABS(q) > TWOFORTY * ULP_OF_ONE_PLUS):
        N = 1
        V9 = (x - ONE_OVER_B) - (ONE - ONE_OVER_B)
        BadCond(err_defect, "Calculated")
        print(" {:0.17e} for".format(POW(x,z)))
        print("\t(1 + ({:0.17e}) ^ ({:0.17e});".format(V9, z))
        print("\tdiffers from correct value by {:0.17e} .".format(q))
        print("\tThis much error may spoil financial")
        print("\tcalculations involving tiny interest rates.")
        doit = False
    else:
        z = (y - x) * TWO + y
        x = y
        y = z
        z = ONE + (x - ONE_MINUS_ULP)*(x - ONE_MINUS_ULP)
        if (z > ONE) and (I < NUM_TRIALS):
            I += 1
        else:
            if x > ONE:
                if N == 0:
                   print("Accuracy seems adequate.")
                doit = False
            else:
                x = ONE + ULP_OF_ONE_PLUS
                y = ULP_OF_ONE_PLUS + ULP_OF_ONE_PLUS
                y += x
                I = 1

milestone = 150   #==============================
print("Testing powers z^q at four nearly extreme values.")
N = 0
q = FLOOR(ONE_HALF - LOG(C) / LOG(A))
Break = False
for z in [A, ONE_OVER_A]:    # Executes 2x if A = 1/A
    x = ONE_OVER_C
    test_power_result(x, z, q)
    q = - q
    x = C
    test_power_result(x, z, q)

print_if_err_cnt_positive()
if N == 0:
    print(" ... no discrepancies found.")
print("")

milestone = 160   #==============================
Pause()
print("Searching for Overflow threshold:")
print("This may generate an error.")
y = - ONE_OVER_C
V9 = ONE_OVER_H * y
I = True
try:
    doit = True
    while doit:
        V = y
        y = V9
        V9 = ONE_OVER_H * y
        doit = V9 < y
except:
    I = False
    V9 = y

z = V9
print("Can `z = -y' overflow?")
print("Trying it on y = {:0.17e} .".format(y))
V9 = - y
V0 = V9
if V - y == V + V0:
    print("Seems O.K.")
else:
    print("finds a ")
    BadCond(err_flaw, "-(-y) differs from y.")

if z != y:
    BadCond(err_serious, "")
    print("overflow past {:0.17e}\n\tshrinks to {:0.17e} .".
          format(y, z))

if I:
    y = V * (ONE_OVER_H * ULP_OF_ONE_PLUS - ONE_OVER_H)
    z = y + ((ONE - ONE_OVER_H) * ULP_OF_ONE_PLUS) * V
    if z < V0:
        y = z
    if y < V0:
        V = y
    if V0 - V < V0:
        V = V0
else:
    V = y * (ONE_OVER_H * ULP_OF_ONE_PLUS - ONE_OVER_H)
    V = V + ((ONE - ONE_OVER_H) * ULP_OF_ONE_PLUS) * y

print("Overflow threshold is V  = {:0.17e} .".format(V))
if I:
    print("Overflow saturates at V0 = {:0.17e} .".format(V0))
else:
    print("There is no saturation value because " +
          "the system traps on overflow.")
V9 = V * ONE
print("No Overflow should be signaled for V * 1 = {:0.17e}".format(V9))
V9 = V / ONE
print("                           nor for V / 1 = {:0.17e} .".format(V9))
print("Any overflow signal separating this * from the one")
print("above is a DEFECT.")
milestone = 170   #==============================
if not (-V < V and -V0 < V0 and -underflow_threshold < V and underflow_threshold < V):
    BadCond(err_failure, "Comparisons involving ")
    print("+-{:g}, +-{:g}\nand +-{:g} are confused by Overflow.".
          format(V, V0, underflow_threshold))

milestone = 175   #==============================
print("")   # JTC: looks related to underflow, but a different test.
for Indx in range(1, 4):
    if Indx == 1:
        z = underflow_threshold
    elif Indx == 2:
        z = min_positive
    else:                # ***BUG: why Indx 3 and 4?
        z = too_tiny_x

    if z != ZERO:
        V9 = SQRT(z)
        y = V9 * V9
        if ((y / (ONE - B * SAFE_ULPS_OF_ONE) < z)
                or y > (ONE + B * SAFE_ULPS_OF_ONE) * z):
            # dgh: fix operator + SAFE_ULPS_OF_ONE --> * SAFE_ULPS_OF_ONE
            if V9 > ULP_OF_ONE_MINUS:
                BadCond(err_serious, "")
            else:
                BadCond(err_defect, "")
            print("Comparison alleges that what prints as z = {:0.17e}".
                  format(z))
            print(" is too far from sqrt(z) ^ 2 = {:0.17e} .".format(y))

milestone = 180   #==============================
for Indx in range(1, 3):
    if Indx == 1:
        z = V
    else:
        z = V0
    V9 = SQRT(z)
    x = (ONE - B * SAFE_ULPS_OF_ONE) * V9
    V9 = V9 * x
    if ((V9 < (ONE - TWO * B * SAFE_ULPS_OF_ONE) * z) or (V9 > z)):
        y = V9
        if x < BIG_B_NTH:
            BadCond(err_serious, "")
        else:
            BadCond(err_defect, "")
        print("Comparison alleges that z = {:0.17e}".format(z))
        print(" is too far from sqrt(z) ^ 2 ({:0.17e}) .".format(y))

milestone = 190   #==============================
Pause()
x = underflow_threshold * V
y = B * B
if x*y < ONE or x > y:
    if x * y < ULP_OF_ONE_MINUS or x > y/ULP_OF_ONE_MINUS:
        BadCond(err_defect, "Badly")
    else:
        BadCond(err_flaw, "")
    print((" unbalanced range; underflow_threshold * V = {:0.17e}\n" +
           "\tis too far from 1.").format(x))

milestone = 200   #==============================
for Indx in range(1, 6):
    if Indx == 1:
        x = ONE_MINUS_ULP
    elif Indx == 2:
        x = ONE + ULP_OF_ONE_PLUS
    elif Indx == 3:
        x = V
    elif Indx == 4:
        x = underflow_threshold
    else:
        x = B

    y = x
    try:
        V9 = (y / x - ONE_HALF) - ONE_HALF
    except:
        print("  x / x  traps when x = {:g}", x)

    if V9 == ZERO:
        continue
    if V9 == -ULP_OF_ONE_MINUS and Indx < 5:
        BadCond(err_flaw, "")
    else:
        BadCond(err_serious, "")
    print("  x / x differs from 1 when x = {:0.17e}", x)
    print("  instead, x / x - 1/2 - 1/2 = {:0.17e} .", V9)

milestone = 210   #==============================
MyZero = ZERO
print("")
print("What message and/or values does Division by ZERO produce?")

print("This can interupt your program.  You can ", end="")
print("skip this part if you wish.")
s = input("Do you wish to compute 1 / 0?\n")
if s.startswith("N") or s.startswith("n"):
    print("O.K. skipping")
else:
    print("    Trying to compute 1 / 0 produces ...")
    try:
        print("  {:0.7e} .".format(ONE / MyZero))
    except:
        print("Computing 1 / 0 triggered an exception.")

s = input("\nDo you wish to compute 0 / 0?\n")
if s.startswith("N") or s.startswith("n"):
    print("O.K. skipping")
else:
    print("\n    Trying to compute 0 / 0 produces ...")
    try:
        print("  {:0.7e} .", ZERO / MyZero)
    except:
        print("Computing 0 / 0 triggered an exception.")

milestone = 220   #==============================
Pause()
print("")
msg = ["FAILUREs  encountered =",
        "SERIOUS DEFECTs  discovered =",
        "DEFECTs  discovered =",
        "FLAWs  discovered ="
       ]
for i in range(0,4):
    if error_count[i]:
        print("The number of  {:>29s} {:d}.".format(msg[i], error_count[i]))

print("")
if (error_count[err_failure] or error_count[err_serious] or
        error_count[err_defect] or error_count[err_flaw]):
    if (error_count[err_failure] + error_count[err_serious] + error_count[
        err_defect] == 0) and (error_count[err_flaw] > 0):
        print("The arithmetic diagnosed seems ", end="")
        print("Satisfactory though flawed.")

    elif (error_count[err_failure] + error_count[err_serious] == 0) and \
            (error_count[err_defect] > 0):
        print("The arithmetic diagnosed may be Acceptable", end="")
        print("despite inconvenient Defects.")

    elif error_count[err_failure] or error_count[err_serious]:
        print("The arithmetic diagnosed has ", end="")
        print("unacceptable Serious Defects.")

    if error_count[err_failure]:
        print("Potentially fatal FAILURE may have spoiled this", end="")
        print(" program's subsequent diagnoses.")

else:
    print("No failures, defects nor flaws have been discovered.")
    if not (flags["mult_rounding"] == "rounded"
            and flags["div_rounding"] == "rounded"
            and flags["add_sub_rounding"] == "rounded"
            and flags["sqrt_rounding"] == "rounded"):
        print("The arithmetic diagnosed seems Satisfactory.")
    else:
        if (flags["uses_sticky_bit"] and
                (B - TWO) * (B - NINE - ONE) == ZERO):
            print("Rounding appears to conform to ", end="")
            # ***JTC: Update the "proopsed" statement?
            print("the proposed IEEE standard P", end="")
            if ((B == TWO) and
                 ((PRECISION - FOUR * THREE * TWO) *
                  ( PRECISION - TWENTY_SEVEN -
                   TWENTY_SEVEN + ONE) == ZERO)):
                print("754", end="")
            else:
                print("854", end="")
            if flags["IEEE"]:
                print(".")
            else:
                print(",\nexcept for possibly Double Rounding", end="")
                print(" during Gradual Underflow.")

        print("The arithmetic diagnosed appears to be Excellent!")


if fpecount:
    print("\nA total of {:d} floating point exceptions were registered.".
          format(fpecount))
print("END OF TEST.")
exit(0)
