    Returns:
        tiny -- smallest well-behaved value (0)   *** why not tiny_B?
        tinier -- first value to exhibit underflow (tiny_B)
        too_tiny -- underflows to 0 or an epsilon value (too_tiny_B)
        u_threshold -- smallest well-behaved value, if underflow degrades
            into nonzero values, or 0 if underflow flushes to 0 (tiny_B)
        tiny_delta -- difference between two values caused by underflow (0)
        save_tiny1 -- value of tiny where tiny_delta computed (0)
        save_tiny2 -- recomputed tiny where tiny_delta computed (0)

    Basic 4450-4520
    """
# ~~~~~~~ tiny_values_and_difference_3
    d = C * one_plus
    # 1 + SAFE_ULPS_OF_ONE should be enough ulps of 1 that d > C.
    if d <= C:
        # But if not, we punt with default values.
        BadCond(err_failure,
                "multiplication gets too many last digits wrong.")
        Pause()
        return 0, tiny_B, too_tiny_B, tiny_B, 0, 0, 0
# ~~~~~~~ tiny_values_and_difference_4
    else:
        tinier = d
        too_tiny = tinier * H
        u_threshold = ZERO
        tiny_delta = ZERO  # indicates no value computed yet
        save_tiny1 = ZERO
        save_tiny2 = ZERO
        while True:
            tiny = tinier
            tinier = too_tiny
            # This loop mirrors the computation in tiny_powers_of_B(),
            # except that the launch point is C*s with nonzero low-order
            # bits, versus C, which is just a power of the radix.
            if (tiny_delta + tiny_delta) <= tiny_delta:
                print("***Uflow loop -- within if: tinier = {:.7e}"
                      .format(tinier))
                save_tiny2 = tinier * ONE_OVER_H
                tiny_delta = FABS(tiny - save_tiny2)   # may underflow to 0
                save_tiny1 = tiny
                if (u_threshold == ZERO) and (tiny != save_tiny2):
                    # Test for 0 captures first time through, in case
                    # tiny_delta underflows to 0.
                    u_threshold = tiny
            # Placing this statement after the (tiny*H)/H test above
            # emphasizes that only nonzero values of tinier qualify for
            # values degraded by underflow.
            too_tiny = too_tiny * H
            print("***Uflow loop -- new too_tiny = {:.7e}".format(too_tiny))
            if ((tinier <= too_tiny)
                    or (too_tiny + too_tiny <= too_tiny)): break
        return (tiny, tinier, too_tiny, u_threshold,
                tiny_delta, save_tiny1, save_tiny2)


