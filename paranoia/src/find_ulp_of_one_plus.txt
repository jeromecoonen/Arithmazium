#INCLUDE para_head recalc_radix.html aaapara_toc.html find_ulp_of_one_minus.html

<h1>find_ulp_of_one_plus()</h1>

<p>
Herein lies one of the splendid numerical idioms of Paranoia.
We'll encounter this technique in several functions to follow.
The idea is this:
</p>

<p class="quote">
<em>
When searching for the smallest value with a given property,
start with any handy value
at least as big and iterate downward.
</em>
</p>

<p>
The code starts with the value \(4 / 3\). We know the decimal expression
\(1.3333\cdots\) and in a moment we'll see that the value in binary is
<code>1.010101...</code> The value must round in any
radix not a multiple of \(3\).
</p>

<p>
What matters is that the rounding error is one or two thirds of an ulp
of <code>1.0</code>, perhaps plus one or more further ulps of <code>1.0</code>,
if the division
is especially sloppy. To see this, look at the decimal number line:
</p>

<object type="image/svg+xml" data="img/4_3_round_d-auto.svg">
  ------Image------
</object>

<p>
The tick marks signify the (highly magnified)
representable numbers between <code>1.0</code> and <code>10.0</code>.
Their spacing defines ulps of <code>1.0</code>. The rounding error
is at least \(0.3333\cdots\)
or \(0.6666\cdots\)
ulp of <code>1.0</code>, depending on the computed (representable) value.
</p>

<p>
The rounding error is \(\pm k / 3\)
ulps of <code>1.0</code> where \(k = 1, 2, 4, 5, 7, 8, \ldots\)
That is, there's a guaranteed one or two odd thirds of an ulp of
<code>1.0</code> in the rounding error.
The same logic applies to binary, octal, and hex arithmetic.
</p>

<p>
After <code>4.0 / 3.0</code> is rounded, the rest of the setup is done
without rounding in any plausible arithmetic. In any case, the thirds
of an ulp error are baked in.
Subtracting <code>1.0</code>
leaves a rounded value of \(1/3\) in the range of numbers
just less than <code>1.0</code>, where the numbers are <code>B</code>
times dense as just above <code>1.0</code>.
</p>

<p>
Subtracting <code>ONE_HALF - third</code>
gives <code>sixth</code> with the same rounding error as <code>third</code>,
but with opposite
sign. The doubled value <code>x</code> has twice the rounding error.
Finally, subtracting
the two approximations of \(1 / 3\) leaves just
the sum of the two error magnitudes.
We've accumulated \(3\) times \(1/3\) or \(2/3\) ulp of <code>1.0</code>,
giving us an ulp or two of <code>1.0</code>.
</p>

<p>
This binary diagram shows the case of even precision in rounded arithmetic.
The lowest-order bits of values are not shown as the subtractions proceed.
They're all zero, by design in this isolation of the ulps of <code>1.0</code>.
</p>

<object type="image/svg+xml" data="img/ulp_one_plus-auto.svg">
  ------Image------
</object>

<p>
The result of the fiddling is at least \(1/3 + 2/3\) ulp of
<code>1.0</code>, but may be another ulp or more larger depending
on the rounding of the arithmetic and the quality of the
division operation.
To guarantee headroom in the iteration,
Paranoia takes the larger of the
<code>x</code> ulps and the <code>guess</code> passed as a parameter.
</p>

<div class="math">
<p>
This highlighted section gives some optional mathematical elaboration.
We rewrite \(4/3\) to expand it in binary.
\[
4/3 = {1 \over {1 - {1/4}}} = 1 + 1/4 + 1/16 + 1/64 + 1/256 + \cdots
\]
which is the binary expression <code>1.010101...</code> above.
</p>

<p>
Lifting out of the bits, we can express the computed
<code>x = FOUR / THREE</code> as
\(4/3 + \epsilon\) where the Greek epsilon represents the rounding.
Multiplying <code>x</code> by \(3\) <em>without rounding</em>,
we have the mathematical value \(4 + 3 \epsilon\)
expressed in ulps of <code>1.0</code>.
Thereffore \(\epsilon\) must be some \(k / 3\) ulps of <code>1.0</code>, where
\(k\) is not a multiple of \(3\).
</p>
</div>

#CODE 265-find_ulp_of_one_plus

<p>
The following iteration exhibits another idiom: the creation of nonzero low-order
digits to encourage an upward round, if there's nearly a half-way case.
The binary diagram below shows how <code>u</code> is halved, but with
some added nonzero low-order bits. Since <code>u</code> is some ulps of
\(1.0\), <code>u * u</code> is some ulps of <code>u</code>.
The factor <code>THIRTY_TWO</code> shifts those bits well back into
<code>u</code> in radix 2, 8, or 16. The diagram continues the binary tale.
</p>

<object type="image/svg+xml" data="img/ulp_one_plus_b-auto.svg">
  ------Image------
</object>

</p>
In decimal, the factor <code>THIRTY_TWO</code> ensures some
nonzero low-order digits in <code>x</code>.
</p>

#CODE 267-find_ulp_of_one_plus2

<h2>Your turn</h2>

<p>
<span class="exer">Exercise:</span> The decimal diagram below
starts the computation in decimal.
Assuming that <code>guess</code> is <code>0.00001</code>, run the iteration
to see that the guess was correct.
</p>

<object type="image/svg+xml" data="img/ulp_one_plus_c-auto.svg">
  ------Image------
</object>

<p>
<span class="exer">Exercise:</span> Replay the binary case with odd precision to see
it works either way.
</p>

#INCLUDE para_foot recalc_radix.html aaapara_toc.html find_ulp_of_one_minus.html
